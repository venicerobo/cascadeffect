#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     IRfront,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S2,     IRright,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     SONAR,          sensorSONAR)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S4_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "turing_constants.c"

void initializeRobot()
{
	servo[servo1] = 0;
	servo[servo2] = AUTO_ARM_STARTING_POSITION;
	servo[servo3] = 0;
  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

}

///////////////////////////////////////////////////////////////////////////////////////////////////////

task main() {
	initializeRobot();
	waitForStart(); // Wait for the beginning of autonomous phase.


	// Drive forward to detect IR.
	nMotorEncoder[motorH] = ENCODER_RESET;
	nMotorEncoder[motorI] = ENCODER_RESET;
	while (nMotorEncoder[motorH]<LONG_DETECT_TICKS && nMotorEncoder[motorI]<LONG_DETECT_TICKS) {
		motor[motorH] = DETECT_IR_SPEED;
		motor[motorI] = -DETECT_IR_SPEED;
	}
	motor[motorH] = 0;
	motor[motorI] = 0;

	if (SensorValue[S1] == 4 || SensorValue[S1] == 3 || SensorValue[S1] == 0) {

		// IR IS 0 DEGREES FROM PARKING ZONE
		if (SensorValue[S1] == 4 && SensorValue[S2] == 1) {
			//Drive straight
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
			while (nMotorEncoder[motorH]<SHORT_DETECT_TICKS && nMotorEncoder[motorI]<SHORT_DETECT_TICKS) {
				motor[motorH] = DETECT_IR_SPEED;
				motor[motorI] = -DETECT_IR_SPEED;
			}
			//Turn 90 counterclockwise
			while (SensorValue[S2] != 5) {
				motor[motorH] = -TURNING_SPEED;
				motor[motorI] = -TURNING_SPEED;
			}
			motor[motorH] = 0;
			motor[motorI] = 0;
		}

		// IR IS 45 DEGREES FROM PARKING ZONE
		if (SensorValue[S1] == 3 && SensorValue[S2] == 0) {
			//IR is 45 deg, so turn 45 deg counterclockwise
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
			while (nMotorEncoder[motorH]>-FORTY_FIVE_TURN_TICKS && nMotorEncoder[motorI]>-FORTY_FIVE_TURN_TICKS) {
				motor[motorH] = -TURNING_SPEED;
				motor[motorI] = -TURNING_SPEED;
			}
			// Drive straight
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
			while (nMotorEncoder[motorH]<ANGLE_DRIVE_TICKS && nMotorEncoder[motorI]<ANGLE_DRIVE_TICKS) {
				motor[motorH] = DETECT_IR_SPEED;
				motor[motorI] = -DETECT_IR_SPEED;
			}
			// Find IR beacon using IRright
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
			while (SensorValue[S2] != 5) {
				motor[motorH] = DETECT_IR_SPEED;
				motor[motorI] = -DETECT_IR_SPEED;
			}
		}

		// IR IS 90 DEGREES FROM PARKING ZONE
		if (SensorValue[S1] == 0 && SensorValue[S2] == 0) {
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
		// Turn 90 deg counterclockwise
			while (nMotorEncoder[motorH]>-NINETY_TURN_TICKS && nMotorEncoder[motorI]>-NINETY_TURN_TICKS) {
				motor[motorH] = -TURNING_SPEED;
				motor[motorI] = -TURNING_SPEED;
			}
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
			while (nMotorEncoder[motorH]<LONG_DETECT_TICKS && nMotorEncoder[motorI]<LONG_DETECT_TICKS) {
				motor[motorH] = HALF_SPEED;
				motor[motorI] = -HALF_SPEED;
			}
		// Turn 90 deg clockwise
			while (nMotorEncoder[motorH]<NINETY_TURN_TICKS && nMotorEncoder[motorI]<NINETY_TURN_TICKS) {
				motor[motorH] = TURNING_SPEED;
				motor[motorI] = TURNING_SPEED;
			}
		// Detect IR
			while (SensorValue[S2] != 5) {
				motor[motorH] = DETECT_IR_SPEED;
				motor[motorI] = DETECT_IR_SPEED;
			}
			motor[motorH] = 0;
			motor[motorI] = 0;
			nMotorEncoder[motorH] = ENCODER_RESET;
			nMotorEncoder[motorI] = ENCODER_RESET;
		}
		// Lift scissorlift and activate autoarm.
		motor[motorG] = SCISSOR_LIFT_MOTOR;
		wait1Msec(LIFTING_TIME);
		motor[motorG] = 0;
		servo[servo2] = AUTO_ARM_DUMP;
		wait1Msec(DUMPING_TIME);
		servo[servo2] = 0;
		motor[motorG] = -SCISSOR_LIFT_MOTOR;
		wait1Msec(LIFTING_TIME);
		// Back up a little
		while (nMotorEncoder[motorH]<SHORT_DETECT_TICKS && nMotorEncoder[motorI]<SHORT_DETECT_TICKS) {
			motor[motorH] = TURNING_SPEED;
			motor[motorI] = TURNING_SPEED;
		}
		//Turn 90 deg clockwise
		while (nMotorEncoder[motorH]<NINETY_TURN_TICKS && nMotorEncoder[motorI]<NINETY_TURN_TICKS) {
			motor[motorH] = TURNING_SPEED;
			motor[motorI] = TURNING_SPEED;
		}
		// Knock kickstand
		while (nMotorEncoder[motorH]<KICKSTAND_DRIVE_TICKS && nMotorEncoder[motorI]<KICKSTAND_DRIVE_TICKS) {
			motor[motorH] = DEAD_RECKONING;
			motor[motorI] = -DEAD_RECKONING;
		}
	}
}
