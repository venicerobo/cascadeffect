#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRfront,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     IRright,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C2_1,     scissor_lift,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     left_wheel,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     right_wheel,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    left_tube_clamp,      tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    right_tube_clamp,     tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "turing_constants_try.c"

void initializeRobot()
{
	servo[left_tube_clamp] = 0;
	servo[right_tube_clamp] = 0;
  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
}

///////////////////////////////////////////////////////////////////////////////////////////////////////

task main() {
	initializeRobot();
	//waitForStart(); // Wait for the beginning of autonomous phase.

	// Drive forward to detect IR.
	nMotorEncoder[left_wheel] = ENCODER_RESET;
	nMotorEncoder[right_wheel] = ENCODER_RESET;


	while (nMotorEncoder[left_wheel]<FIRST_DETECT_TICKS && nMotorEncoder[right_wheel]<FIRST_DETECT_TICKS) {
		motor[left_wheel] = DETECT_IR_SPEED;
		motor[right_wheel] = -DETECT_IR_SPEED;
	}
	motor[left_wheel] = 0;
	motor[right_wheel] = 0;

	if (SensorValue[IRfront] == 4 || SensorValue[IRfront] == 3 || SensorValue[IRfront] == 0) {

		// IR IS 0 DEGREES FROM PARKING ZONE
		if (SensorValue[IRfront] == 4) {
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
			//Turn 180 deg counterclockwise
			while (SensorValue[IRright] != 5) {
				motor[left_wheel] = -TURNING_SPEED;
				motor[right_wheel] = -TURNING_SPEED;
			}
			motor[left_wheel] = 0;
			motor[right_wheel] = 0;
		}

		// IR IS 45 DEGREES FROM PARKING ZONE
		if (SensorValue[IRfront] == 3 && SensorValue[IRright] == 0) {
			//IR is 45 deg, so turn 45 deg counterclockwise
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
			while (nMotorEncoder[left_wheel]>-FORTYDEG_TURN_TICKS && nMotorEncoder[right_wheel]>-FORTYDEG_TURN_TICKS) {
				motor[left_wheel] = -TURNING_SPEED;
				motor[right_wheel] = -TURNING_SPEED;
			}
			// Drive straight
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
			while (nMotorEncoder[left_wheel]<ANGLE_DRIVE_TICKS && nMotorEncoder[right_wheel]<ANGLE_DRIVE_TICKS) {
				motor[left_wheel] = DETECT_IR_SPEED;
				motor[right_wheel] = -DETECT_IR_SPEED;
			}
			// Find IR beacon using IRright
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
			while (SensorValue[IRright] != 5) {
				motor[left_wheel] = DETECT_IR_SPEED;
				motor[right_wheel] = -DETECT_IR_SPEED;
			}
		}

		// IR IS 90 DEGREES FROM PARKING ZONE
		if (SensorValue[IRfront] == 0 && SensorValue[IRright] == 0) {
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
		// Turn 90 deg counterclockwise
			while (nMotorEncoder[left_wheel]>-NINETY_TURN_TICKS && nMotorEncoder[right_wheel]>-NINETY_TURN_TICKS) {
				motor[left_wheel] = -TURNING_SPEED;
				motor[right_wheel] = -TURNING_SPEED;
			}
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
			while (nMotorEncoder[left_wheel]<FIRST_DETECT_TICKS && nMotorEncoder[right_wheel]<FIRST_DETECT_TICKS) {
				motor[left_wheel] = HALF_SPEED;
				motor[right_wheel] = -HALF_SPEED;
			}
		// Turn 90 deg clockwise
			while (nMotorEncoder[left_wheel]<NINETY_TURN_TICKS && nMotorEncoder[right_wheel]<NINETY_TURN_TICKS) {
				motor[left_wheel] = TURNING_SPEED;
				motor[right_wheel] = TURNING_SPEED;
			}
		// Detect IR
			while (SensorValue[IRright] != 5) {
				motor[left_wheel] = DETECT_IR_SPEED;
				motor[right_wheel] = DETECT_IR_SPEED;
			}
			motor[left_wheel] = 0;
			motor[right_wheel] = 0;
			nMotorEncoder[left_wheel] = ENCODER_RESET;
			nMotorEncoder[right_wheel] = ENCODER_RESET;
		}
		// Lift scissorlift and activate autoarm.
		motor[motorG] = SCISSOR_LIFT_MOTOR;
		wait1Msec(LIFTING_TIME);
		motor[motorG] = 0;
		servo[servo2] = AUTO_ARM_DUMP;
		wait1Msec(DUMPING_TIME);
		servo[servo2] = 0;
		motor[motorG] = -SCISSOR_LIFT_MOTOR;
		wait1Msec(LIFTING_TIME);
		// Back up a little
		while (nMotorEncoder[left_wheel]<SECOND_DETECT_TICKS && nMotorEncoder[right_wheel]<SECOND_DETECT_TICKS) {
			motor[left_wheel] = TURNING_SPEED;
			motor[right_wheel] = TURNING_SPEED;
		}
		//Turn 90 deg clockwise
		while (nMotorEncoder[left_wheel]<NINETY_TURN_TICKS && nMotorEncoder[right_wheel]<NINETY_TURN_TICKS) {
			motor[left_wheel] = TURNING_SPEED;
			motor[right_wheel] = TURNING_SPEED;
		}
		// Knock kickstand
		while (nMotorEncoder[left_wheel]<KS_DRIVE_TICKS && nMotorEncoder[right_wheel]<KS_DRIVE_TICKS) {
			motor[left_wheel] = DEAD_RECKONING;
			motor[right_wheel] = -DEAD_RECKONING;
		}
	}
}
